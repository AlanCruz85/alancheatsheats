
Remember: when you use 'view page source', you only see the html/js writted in the file. You don't see the php writed, for example.

Ex: 	<?php  some codes ... ?> you will not see this part
	<html> But will see this part
		<head>    </head>
		<body>	  </body>
	</html>
	
Ex2: 	^date^ : Current Date (<?php echo date("d/m/Y");?>)
	^time^ : Current Time (<?php echo date("h:i:s a", time());?>)
	Here, I will not see the <?php .....?> part. I can try to deduce the code seeing the behaviour displayed.

__________________________________________________________________________________________________________________________________________________________
Directory enumeration:
feroxbuster -u http://shoppy.htb/ -w /usr/share/wordlists/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -x php,html --no-state

If you have domain name:
		Subdomain enumeration:
		wfuzz -u http://siteisup.htb/ -H "Host:http://FUZZ.siteisup.htb/" -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt
	
________________________________________________________________________________________________________________________________________________________________	
If is a https:
		sslscan <<IP>> -> See if it is vulnerable to heartbleed

________________________________________________________________________________________________________________________________________________________________
		
If the website uses a file that you upload to do something besides storing it (parsing and getting informations, or using to create a gif, in case of a image), try to find which program is being used. You maybe can find a vulnerable program.

________________________________________________________________________________________________________________________________________________________

Turning GET into POST:
I don't know if I will use this, but, just in case...
"Now this was a harder part to figure out. There’s a technique called request smuggling, that is based upon the fact that usually there exists a front-end server, that sends multiple requests to the back-end server at once. This is done because it’s a lot more performant, and makes thing go brrr. HTTP requests are sent one after another, and the receiving server parses the HTTP request headers to determine where one request ends and the next one begins. One way of exploiting this is by setting the Content-Length as 0, so that the backend server processes this as no data, and then send another request afterwards

So we could do something along the lines of:

/ HTTP/1.1
Host: 127.0.0.1:1337
Content-Length: 0

POST /register HTTP/1.1
Host: 127.0.0.1:1337
Content-Type: application/x-www-form-urlencoded
Content-Length: LENGTH OF PAYLOAD
PAYLOAD

GET /?lol=

"
SOURCE: https://cavetownie.github.io/posts/htb_weatherapp/
