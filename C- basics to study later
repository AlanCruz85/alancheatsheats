
undefined4 main(void){
  __gid_t __rgid;
  
  setvbuf(stdout,(char *)0x0,2,0);
  __rgid = getegid();
  setresgid(__rgid,__rgid,__rgid);
  puts("You know who are 0xDiablos: ");
  vuln();
  return 0;
}

This function simply prints to screen and calls the function vuln
##########

void vuln(void){
  char local_bc [180];
  
  gets(local_bc);
  puts(local_bc);
  return;
}

A char array of size 180 is allocated that will hold the received input using the gets function and print it. This function was predicated since it is susceptible to suffer from buffer overflow attacks and was replaced by fgets. This is a potential attack vector and is worth further investigation.

gets() doesn’t do any array bound testing. gets() keeps on reading until it sees a newline character. 
To avoid Buffer Overflow, fgets() should be used instead of gets() as fgets() makes sure that not more than MAX_LIMIT characters are read.

>>>Given the analysis made on the previous tool the plan is trying to exploit the get function in vuln() using a buffer overflow attack to jump into the flag() function and get the flag.<<<
############

void flag(int param_1,int param_2){
  char local_50 [64];
  FILE *local_10;
  
  local_10 = fopen("flag.txt","r");
  if (local_10 != (FILE *)0x0) {
    fgets(local_50,0x40,local_10);
    if ((param_1 == -0x21524111) && (param_2 == -0x3f212ff3)) {
      printf(local_50);
    }
    return;
  }
  puts("Hurry up and try in on server side.");
                    /* WARNING: Subroutine does not return */
  exit(0);
}

This function allocates a char array of size 64 (local_50), reads the file “flag.txt” content, and saves it to the local_50. If the function parameters (param_1 and param_2) are the same has “-0x21524111” and “-0x3f212ff3“ (let’s call them X{x1, x2}) respectively it prints the local_50 content, which holds the flag. 



