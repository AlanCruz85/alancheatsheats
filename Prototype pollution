
############################################################################################
https://book.hacktricks.xyz/pentesting-web/deserialization/nodejs-proto-prototype-pollution#
https://learn.snyk.io/lessons/prototype-pollution/javascript/                              #
Excelent explaination in these websites.                                                   #
############################################################################################

The merge function that startup.io wrote aimed to update one object with all attributes of another object. As we saw when we toured the code in the last section, the merge function is recursive and merrily merges all properties from its second input--even when it contains untrusted data with dubious keys such as __proto__.
Merging two objects is not the only functionality that can expose the code to a prototype pollution attack—any function which recursively sets nested properties can create an attack vector. Other common examples in the JavaScript ecosystem include: deep cloning (e.g. lodash cloneDeep), setting nested properties (e.g. lodash set), or creating objects by recursively "zipping" properties with values (e.g. lodash zipObjectDeep).
__________________________________________________________________________________________________________________________________________________

SOURCE: https://medium.com/@zub3r.infosec/exploiting-prototype-pollutions-220f188438b2

Prototypes are the mechanism by which objects can inherit features from one another. This means that objects can act as a template for other inheriting objects, that will themselves maybe be inherited and so on. This course of action is called a prototype chain. It is the reason why some objects will have properties of other objects and why it is so easy to transfer those properties."

" An attacker needs to be able to manipulate __proto__, the malicious actor could with that possibility change the applications behaviour.
As explained above, every object inherits the prototypes from their prototype (redCar from Car and Car from Object). Attackers could take advantage of that feature to pollute Object.prototype, which will cause each javascript object to be polluted.

redCar.__proto__.__proto__.toString = function() {
    console.log("Polluted with the __proto__ property")
};

Calling the toString() method on any object after executing this code would now log “Polluted with the __proto__ property” to the console, instead of returning a string that would represent the object as it should normally do."

In other words: you use the object to modify the atributes and functions that belong to the father.
_________________________________________________________________________________________________________________________________________________________

"Using the constructor property

Another way to achieve prototype pollution of all JS objects with the prototype property without using Object is to use the constructor property.
This property returns a reference to the Object constructor function that created the instance object. This means that, for our redCar instance, this will be the Car constructor function. But running it on an object created directly from Object.prototype like Car or any objects that got generated without intermediary constructor functions, will give us the desired Object prototype back.

simpleObject.constructor.prototype.toString = function() {
    console.log("Polluted with the constructor property.")
}  

SAME SOURCE: https://medium.com/@zub3r.infosec/exploiting-prototype-pollutions-220f188438b2
________________________________________________________________________________________________________________________________________________________







