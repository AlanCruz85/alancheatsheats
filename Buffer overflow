

undefined4 main(void){
  __gid_t __rgid;
  
  setvbuf(stdout,(char *)0x0,2,0);
  __rgid = getegid();
  setresgid(__rgid,__rgid,__rgid);
  puts("You know who are 0xDiablos: ");
  vuln();
  return 0;
}

This function simply prints to screen and calls the function vuln
##########

void vuln(void){
  char local_bc [180];
  
  gets(local_bc);
  puts(local_bc);
  return;
}

A char array of size 180 is allocated that will hold the received input using the gets function and print it. This function was predicated since it is susceptible to suffer from buffer overflow attacks and was replaced by fgets. This is a potential attack vector and is worth further investigation.

gets() doesn’t do any array bound testing. gets() keeps on reading until it sees a newline character. 
To avoid Buffer Overflow, fgets() should be used instead of gets() as fgets() makes sure that not more than MAX_LIMIT characters are read.

>>>Given the analysis made on the previous tool the plan is trying to exploit the get function in vuln() using a buffer overflow attack to jump into the flag() function and get the flag.<<<
############

void flag(int param_1,int param_2){
  char local_50 [64];
  FILE *local_10;
  
  local_10 = fopen("flag.txt","r");
  if (local_10 != (FILE *)0x0) {
    fgets(local_50,0x40,local_10);
    if ((param_1 == -0x21524111) && (param_2 == -0x3f212ff3)) {
      printf(local_50);
    }
    return;
  }
  puts("Hurry up and try in on server side.");
                    /* WARNING: Subroutine does not return */
  exit(0);
}

This function allocates a char array of size 64 (local_50), reads the file “flag.txt” content, and saves it to the local_50. If the function parameters (param_1 and param_2) are the same has “-0x21524111” and “-0x3f212ff3“ (let’s call them X{x1, x2}) respectively it prints the local_50 content, which holds the flag. 

The continued process will be using GDB with peda. The program was opened with the tool to check if the methodology can be performed, by checking if security features are turned off and start the exploit development.

checksec --file=./vuln
CANARY    : disabled
FORTIFY   : disabled
NX        : disabled
PIE       : disabled
RELRO     : Partial

Since all the security features are turned off the planned methodology can be carried out. It is important to get familiar with Canary, NX, and ASLR.

If we launch GDB, we can use the “info file” command to see the entry point’s address. True enough, the entry point matches the address of start() (check the file with ghidra)

(gdb) info file
Symbols from "/home/kali/pentest/hackthebox/box/vuln".
Local exec file:
        `/home/kali/pentest/hackthebox/box/vuln', file type elf32-i386.
        Entry point: 0x80490d0
        0x08048194 - 0x080481a7 is .interp
        0x080481a8 - 0x080481cc is .note.gnu.build-id
        0x080481cc - 0x080481ec is .note.ABI-tag
        0x080481ec - 0x0804820c is .gnu.hash

Setting the breakpoint before and after gets(), we will be able to analyze the stack to ensure we only need 184 bytes (local_bc needs 180 bytes + 4 bytes of register EBP) to reach the location of the return (RET) address

(gdb) b *0x08049291
Breakpoint 1 at 0x08049291
(gdb) b *0x08049296
Breakpoint 2 at 0x0804296
(gdb) r

See the rest in the sources bellow. This was only to remind you of the basics.
SOURCE: https://shakuganz.com/2021/06/08/hackthebox-you-know-0xdiablos-write-up/
        https://weshsec.medium.com/htb-you-know-0xdiablos-4ad297fe75c0

_____________________________________________________________________________________________________________________________________________

